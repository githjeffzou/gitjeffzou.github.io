{"meta":{"title":"zoug2016","subtitle":"blog","description":"share ebd dev","author":"zoug2016","url":"https://zoug2016.github.io","root":"/"},"pages":[{"title":"关于我","date":"2023-05-03T04:23:29.808Z","updated":"2023-05-03T04:23:29.808Z","comments":false,"path":"about/index.html","permalink":"https://zoug2016.github.io/about/index.html","excerpt":"","text":"一名车载嵌入式开发工程师 ● ASPICE ● ISO26262 ● ARM ● RTOS ● Linux ● Compile ● CyberSecurity ● Driver Development ● … E-mail: zoug2016@qq.com"},{"title":"分类","date":"2023-05-03T02:59:32.260Z","updated":"2023-05-03T02:59:32.260Z","comments":false,"path":"categories/index.html","permalink":"https://zoug2016.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-05-03T02:59:36.462Z","updated":"2023-05-03T02:59:36.462Z","comments":false,"path":"tags/index.html","permalink":"https://zoug2016.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"008-windows-batch","slug":"008-windows-batch","date":"2023-05-31T16:55:11.000Z","updated":"2023-05-31T17:07:45.706Z","comments":true,"path":"2023/06/01/008-windows-batch/","link":"","permalink":"https://zoug2016.github.io/2023/06/01/008-windows-batch/","excerpt":"","text":"打开windows批处理大门 - 知乎 (zhihu.com)Windows 批处理脚本指南：引言 - 简书 (jianshu.com)英文原文：Guide to Windows Batch Scripting - &#x2F;* steve jansen *&#x2F; (steve-jansen.github.io) 引言Why Windows？Why DOS-style Batch Files? 批处理入门手册_w3cschool","categories":[{"name":"cmd","slug":"cmd","permalink":"https://zoug2016.github.io/categories/cmd/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://zoug2016.github.io/tags/cmd/"}],"author":"zoug2016"},{"title":"007-nodejs-start","slug":"007-nodejs-start","date":"2023-05-31T16:18:40.000Z","updated":"2023-05-31T16:45:39.373Z","comments":true,"path":"2023/06/01/007-nodejs-start/","link":"","permalink":"https://zoug2016.github.io/2023/06/01/007-nodejs-start/","excerpt":"","text":"hello world12345//hello worldvar hello = &#x27;Hello world!&#x27;;console.log(hello); 保存为hello.js 执行 node hello.js 执行时传递参数12var arguments = process.argv.splice(2);console.log(&#x27;所传递的参数是：&#x27;, arguments); 输出： 所传递的参数是： [ ‘a’, ‘b’, ‘c’ ] 123process.argv.forEach(function (val, index, array) &#123; console.log(index + &#x27;: &#x27; + val);&#125;); 输出： 从命令行接收参数所传递进来的值 tj大神的commander.js https://github.com/visionmedia/commander.js 1234567891011121314151617181920#!/usr/bin/env node /** * Module dependencies. */var program = require(&#x27;commander&#x27;); program .version(&#x27;0.0.1&#x27;) .option(&#x27;-p, --peppers&#x27;, &#x27;Add peppers&#x27;) .option(&#x27;-P, --pineapple&#x27;, &#x27;Add pineapple&#x27;) .option(&#x27;-b, --bbq&#x27;, &#x27;Add bbq sauce&#x27;) .option(&#x27;-c, --cheese [type]&#x27;, &#x27;Add the specified type of cheese [marble]&#x27;, &#x27;marble&#x27;) .parse(process.argv); console.log(&#x27;you ordered a pizza with:&#x27;);if (program.peppers) console.log(&#x27; - peppers&#x27;);if (program.pineapple) console.log(&#x27; - pineapple&#x27;);if (program.bbq) console.log(&#x27; - bbq&#x27;);console.log(&#x27; - %s cheese&#x27;, program.cheese); 参考Node.js 简介 (nodejs.cn) Node.js 教程 | 菜鸟教程 (runoob.com)","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://zoug2016.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://zoug2016.github.io/tags/nodejs/"}],"author":"zoug2016"},{"title":"006-hexo-basic","slug":"006-hexo-basic","date":"2023-05-31T15:42:26.000Z","updated":"2023-05-31T15:57:29.130Z","comments":true,"path":"2023/05/31/006-hexo-basic/","link":"","permalink":"https://zoug2016.github.io/2023/05/31/006-hexo-basic/","excerpt":"","text":"写作(new)创建一篇新文章或者新的页面 1hexo new [layout] &lt;title&gt; 命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 然后使用Typora或vs code来编写markdown generate 1$ hexo generate 该命令可以简写为 1hexo g server1$ hexo server 该命令可以简写为 hexo s 即可本查看浏览，没有问题后再部署 deploy1$ hexo deploy 该命令可以简写为： 1$ hexo d clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public) 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 参考文档 | Hexo","categories":[{"name":"hexo","slug":"hexo","permalink":"https://zoug2016.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zoug2016.github.io/tags/hexo/"}],"author":"zoug2016"},{"title":"005-c-pointer-summary","slug":"005-c-pointer-summary","date":"2023-05-05T14:40:35.000Z","updated":"2023-05-05T17:01:42.800Z","comments":true,"path":"2023/05/05/005-c-pointer-summary/","link":"","permalink":"https://zoug2016.github.io/2023/05/05/005-c-pointer-summary/","excerpt":"","text":"指针是一种保存变量地址的变量 声明解释先从最内层开始 先从名字p的右边开始看，再到左边。 然后跳到外一层右边开始，再到外一层的左边开始看。 不断循环，直到没有符号为止 函数指针与指针函数 指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。 声明格式为：类型标识符* 函数名(参数表) 12int fun(int x,int y); //一个函数，然后返回值是一个 int 类型，是一个数值int* fun(int x,int y); //唯一的区别就是在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。 函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。 类型说明符 (*函数名) (参数) 12345678910int (*fun)(int x,int y); 函数指针是需要把一个函数的地址赋值给它，有两种写法：fun = &amp;Function；fun = Function;取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。调用函数指针的方式也有两种：x = (*fun)();x = fun();两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。 数组指针与指针数组 指针数组 首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。 数组指针 首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。 A) int *p1[10]; B) int (*p2)[10]; 到底哪个是数组指针，哪个是指针数组呢 “[]”的优先级比“”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int 修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即**指针数组 至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。 我们可以借助下面的图加深理解： 复杂指针声明声明简单的指针变量如下代码： 1234int a = 100;int *p; //声明一个指向int类型的指针变量pp = &amp;a; //把a的地址赋值给指针p*p = 1000; //修改a值为1000 这段代码声明了一个指针变量p，赋值指向了a，可通过*p访问到变量a，并对a进行值的修改。星号 * 是一元运算符，它用在不同的地方将具有不同的作用。 星号 * 用于声明语句时的作用上面代码中的第二行中的 * 对于指针的声明，首先从p这里开始看，这是c语言中声明的语法 第1步：先看p的右边有没有其他符号（分号不算），可以看到p的右边没有符号 第2步：看p的左边，在p的左边有一个星号 * ，这里的 * 作用在p上面，其产生的效果是声明变量p是一个指针。到目前只知道p是一个指针，但还不知道该指针是指向什么类型的数据 第3步：星号 * 左边是数据类型int，int的作用是声明p指向的数据类型是int类型 1上面的int和*两个符号的发挥作用是有先后顺序的，先是 * 发挥作用声明p是一个指针，然后是int发挥作用，声明指向的数据类型是int 星号 * 用于声明语句之外时的作用代码中*p &#x3D; 1000;中 * 用于声明语句之外时的作用，这句等效于 a &#x3D; 1000; 当 * 作用于指针变量p时，就时访问指针变量p所指向的变量a。 复杂声明和声明语法声明指向指针的指针变量代码如下： 123456int a = 100;int *p; //声明一个指向int类型的指针变量pp = &amp;a; //把a的地址赋值给指针pint **pp;//声明指向指针的指针变量pppp = &amp;p;//pp指向变量p, p是指针变量**p = 1000; //修改a值为1000 前三行代码在前面已经介绍过了 主要对第四行开始的代码进行介绍： 第四行 int **pp;与 int *(* pp);是等效的，因为* 和 ++ 这样的一元运算符遵循从右往左的结合顺序。 对int *(* pp)；进行分析，从变量名pp开始： 第1步：先看pp右边有一个右括号，括号只是强调结合顺序，不用管它 第2步：看pp的左边，可以看到右数的第一个*, 该星号的作用是声明变量pp是一个指针，此时还不知道pp所指向的数据类型 第3步：先看括号的右边，没有其他符号，分号只是语句的结束而已 第4步：看括号的左边，是一个* (右数第二个星号)，这个星号的作用是：声明指针变量pp所指向的数据类型是指针类型，此时我知道了pp指向的数据类型是指针类型（即代码中p的数据类型），但还不知道所指向的指向是指向什么类型的数据。 第5步：看最左边的符号是int，这个int的作用是：声明pp指向的指针所指向的数据类型是int，即pp指向的是int类型的指针。 总结下：pp左边第一个星号 * 声明了pp是一个指向变量，第二个星号 * 声明了指针变量pp指向的数据类型是指针类型，而类型说明符int则声明了pp指向的指针指向的数据类型是int C语言中声明的语法在c语言中解释一个声明，并不是从左到右，也不是从右到左解释，而是从变量名开始解释。声明总是由很多符号和唯一的变量名结合而成，这些符号和唯一的变量名结合就是声明符。 声明的形式为：“T D”, 其中T表示类型，D代表声明符，如： int *p; int就是T, *p就是D。 下面以变量名p和很多符号来结合组成声明符，如[], (), *。 当p与符号[]相结合（[]在p的右边）时，符号[]的作用是声明变量p是一个数组类型。[]中的数字决定了数组中的元素的个数。如下面的声明代码： int p[10]; &#x2F;&#x2F; 声明变量p是一个整型数组，数组中有5个元素 需要主要的是**[]的优先级比星号 * 的优先级高**。 当 p 与符号 （）结合时（ （）在p的右边），符号（）的作用就是声明p时一个函数，通过p()可以调用该函数，（）中的可以有参数列表或无参数列表，如下面的代码： int p(); &#x2F;&#x2F;声明函数p，返回类型是int int p(int a, int b); &#x2F;&#x2F;声明一个带形参int类型的a和b的函数p，返回数据类型是int 同样符号（）的优先级比 * 高 当 p和星号 * 相结合时（星号在p的左边），符号 * 的作用就是声明p是一个指针类型，如下代码： int *p; &#x2F;&#x2F;声明p是一个指针，该指针指向int数据类型 介绍完这3个符号后，继续介绍语法：在介绍声明时，首先要决定声明的变量p是什么东西，而和p最近的符号则决定了p是什么东西。如下面的声明： int p(); &#x2F;&#x2F; p是函数 int *p; &#x2F;&#x2F; p是指针 int p[5]; &#x2F;&#x2F; p是数组 int *p[5];&#x2F;&#x2F; p是数组，数组里面有5个元素，每个元素是指向int类型的指针 对int p[5];进行下解释，由于[]的优先级比 * 高，所以[]先作用于p，故p是一个数组，再看左边是，说明数组中的元素是指针类型，再往左知道了指向的是int数据类型，所以这个声明的结果就是：声明了一个数组，数组有5个元素，每个元素都是指向int整型数据的指针。 总结就是：解释声明要名字p开始，然后从p的右边开始看符号，决定了p是什么（优先级高的符号是[]和（），如果有符号先和p结合，是数组或函数），p左边的符号发挥作用（要么是*，要是什么都没有），最后发挥作用的是类型说明（它在最外面）。 就是不断问什么，然后从里往外看符号来解答什么的过程。 解释声明的方法就是：先从最内层开始看符号，先从名字p的右边开始看，再到左边。然后跳到外一层右边开始，再到外一层的左边开始看。不断循环，直到没有符号为止 下面进行更加复杂的声明解释： char (*(*x())[])(); 先从最里面x变量名开始，x的右边是（），所以x是函数。 再看x的左边，是一个星号 * ，所以x是函数，返回值类型是指针类型 继续跳外一层开始，右边是[], 所以指针指向的是一个数组，再看左边是*，所以数组中的元素的类型是指针类型 再看外一层，右边是()，所以数组中的指针指向的是函数，最后看左边的类型是char，所以函数的返回值类型是char类型。 整个声明就是：x是一个函数，函数的返回类型是指针类型，这个指针指向的是一个数组，这个数组是指针数组（里面元素是指针），数组中的指针是函数指针，指向的函数的返回值类型是char类型。 char (*(*x[3])())[5]; 声明的结果是：x是一个数组，数组有3个元素，元素的类型是指针类型，指针是函数指针，所指向的函数返回值为指针，返回的指针指向数组，数组有5个元素，元素的数据类型为char类型。 使用复杂声明比如：声明一个函数x，函数x的返回值是指针类型，该指针指向数组，数组的元素类型为char。 函数x x() 函数x的返回值是指针类型 *x() 指针指向数组 (*x())[] 数组的元素类型为char char (*x())[]; 对（*(void(*)())0)() 解释，来源于c陷阱与缺陷 找中间位置，是一个指针，指针指向函数即函数指针。 0强制转为函数指针，然后获取函数指针的内容 进行函数调用，即对0地址进行函数调用 优雅一点改进： typedef void (*pfun)(void); (*(pfun)0)();","categories":[{"name":"c","slug":"c","permalink":"https://zoug2016.github.io/categories/c/"},{"name":"c_pointer","slug":"c/c-pointer","permalink":"https://zoug2016.github.io/categories/c/c-pointer/"}],"tags":[{"name":"c","slug":"c","permalink":"https://zoug2016.github.io/tags/c/"}],"author":"zoug2016"},{"title":"004-freertos-mpu-cm3-demo","slug":"004-freertos-mpu-cm3-demo","date":"2023-05-03T15:13:02.000Z","updated":"2023-05-03T16:42:54.025Z","comments":true,"path":"2023/05/03/004-freertos-mpu-cm3-demo/","link":"","permalink":"https://zoug2016.github.io/2023/05/03/004-freertos-mpu-cm3-demo/","excerpt":"","text":"FreeRTOS中使用MPU进行任务之间的隔离，本文主要分析Cortex-M3的demo代码和kernel的实现过程 为了任务之间安全隔离，在FeeRTOS中可以使用MPU（需硬件支持）进行任务之间的隔离，本文主要分析Cortex-M3的demo支持MPU的主要代码框架 源码说明https://github.com/FreeRTOS/FreeRTOS中demo的源码，其中FreeRTOS/Source为kernel代码，作为FreeRTOS git库的submodule，其代码工程在https://github.com/FreeRTOS/FreeRTOS-Kernel 为了查看分析代码方便，可直接在https://github.com/FreeRTOS/FreeRTOS/releases中下载源码包，我下载当前最新的是[FreeRTOSv202212.01](https://github.com/FreeRTOS/FreeRTOS/releases/tag/202212.01) 解压FreeRTOSv202212.01后，要分析的M3的相关代码如下： App demo FreeRTOS\\Demo\\CORTEX_MPU_M3_NUCLEO_L152RE_GCC FreeRTOS\\Demo\\CORTEX_MPU_M3_NUCLEO_L152RE_GCC\\Demo\\mpu_demo.c prvROAccessTask Implements the task which has Read Only access to the memory region ucSharedMemory. prvRWAccessTask Implements the task which has Read Write access to the memory region ucSharedMemory. vStartMPUDemo 定义栈 xROAccessTaskStack 和 xRWAccessTaskStack 定义任务的参数xROAccessTaskParameters和xRWAccessTaskParameters， 包括xRegions xTaskCreateRestricted( &amp;( xROAccessTaskParameters ), NULL ) unprivileged task with RO access to ucSharedMemory. xTaskCreateRestricted( &amp;( xRWAccessTaskParameters ), NULL ) unprivileged task with RW access to ucSharedMemory. FreeRTOS kernel实现代码 FreeRTOS\\Source 头文件在FreeRTOS\\Source\\include FreeRTOS\\Source\\event_groups.c FreeRTOS\\Source\\list.c FreeRTOS\\Source\\queue.c FreeRTOS\\Source\\tasks.c FreeRTOS\\Source\\timers.c 实现MPU的CM3移植代码 FreeRTOS\\Source\\portable\\GCC\\ARM_CM3_MPU FreeRTOS\\Source\\portable\\GCC\\ARM_CM3_MPU\\portmacro.h Type definitions. 123456789101112#define portCHAR char #define portFLOAT float #define portDOUBLE double #define portLONG long #define portSHORT short #define portSTACK_TYPE uint32_t #define portBASE_TYPE long typedef portSTACK_TYPE StackType_t; typedef long BaseType_t; typedef unsigned long UBaseType_t; ... MPU specific constants. 123456789101112 ... typedef struct MPU_REGION_REGISTERS &#123; uint32_t ulRegionBaseAddress; uint32_t ulRegionAttribute; &#125; xMPU_REGION_REGISTERS;/* Plus 1 to create space for the stack region. */ typedef struct MPU_SETTINGS &#123; xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS_IN_TCB ]; &#125; xMPU_SETTINGS; SVC numbers for various services 123#define portSVC_START_SCHEDULER 0 #define portSVC_YIELD 1 #define portSVC_RAISE_PRIVILEGE 2 Scheduler utilities. #define portYIELD() __asm volatile ( “ SVC %0 \\n”::”i” ( portSVC_YIELD ) : “memory” ) portYIELD_WITHIN_API() portYIELD_FROM_ISR( x ) Critical section management Generic helper function. Store&#x2F;clear the ready priorities in a bit map Checks whether or not the processor is privileged. Raise an SVC request to raise privilege. #define portRAISE_PRIVILEGE() __asm volatile ( “svc %0 \\n” ::”i” ( portSVC_RAISE_PRIVILEGE ) : “memory” ); Lowers the privilege level by setting the bit 0 of the CONTROL register. ​ FreeRTOS\\Source\\portable\\GCC\\ARM_CM3_MPU\\port.c Constants required to access and manipulate the NVIC - Constants required to access and manipulate the MPU. - Constants required to access and manipulate the SysTick. - Constants required to check the validity of an interrupt priority - Offsets in the stack to the parameters when inside the SVC handler. - Standard FreeRTOS exception handlers. &gt; void xPortPendSVHandler( void ) __attribute__( ( naked ) ) PRIVILEGED_FUNCTION; &gt; &gt; void xPortSysTickHandler( void ) __attribute__( ( optimize( &quot;3&quot; ) ) ) PRIVILEGED_FUNCTION; &gt; &gt; void vPortSVCHandler( void ) __attribute__( ( naked ) ) PRIVILEGED_FUNCTION; - Starts the scheduler by restoring the context of the first task to run. &gt; static void prvRestoreContextOfFirstTask( void ) - C portion of the SVC handler &gt; /* &gt; &gt; \\* C portion of the SVC handler. The SVC handler is split between an asm entry &gt; &gt; \\* and a C wrapper for simplicity of coding and maintenance. &gt; &gt; */ &gt; &gt; static void prvSVCHandler( uint32_t * pulRegisters ) __attribute__( ( noinline ) ) PRIVILEGED_FUNCTION; - pxPortInitialiseStack - vPortSVCHandler SVC软中断后执行的函数，调用过程为： **vPortSVCHandler** -&gt; static void prvSVCHandler( uint32_t * pulParam ) ​ -&gt; portSVC_START_SCHEDULER ​ -&gt; prvRestoreContextOfFirstTask() ​ -&gt; portSVC_YIELD ​ -&gt;portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT [**触发PENSV**] ​ -&gt; portSVC_RAISE_PRIVILEGE 1234567__asm volatile(&quot; mrs r1, control \\n&quot;/* Obtain current control value. */&quot; bic r1, #1 \\n&quot;/* Set privilege bit. */&quot; msr control, r1 \\n&quot;/* Write back new control value. */::: &quot;r1&quot;, &quot;memory&quot;); ​ - prvRestoreContextOfFirstTask - xPortStartScheduler - vPortEndScheduler - vPortEnterCritical - vPortExitCritical - xPortPendSVHandler - Disable MPU. - read and write 4 sets of MPU registers. - Enable MPU - xPortSysTickHandler &gt; /* Pend a context switch. */ &gt; &gt; portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT; - vPortSetupTimerInterrupt - prvSetupMPU - prvGetMPURegionSizeSetting - xIsPrivileged - vResetPrivilege - vPortStoreTaskMPUSettings &gt; 在task.c中prvInitialiseNewTask和vTaskAllocateMPURegions中调用 任务的MPU属性配置FreeRTOS\\Demo\\CORTEX_MPU_M3_NUCLEO_L152RE_GCC\\Demo\\mpu_demo.c 12345678910111213141516171819202122232425262728TaskParameters_t xROAccessTaskParameters =&#123; .pvTaskCode = prvROAccessTask, .pcName = &quot;ROAccess&quot;, .usStackDepth = configMINIMAL_STACK_SIZE, .pvParameters = NULL, .uxPriority = tskIDLE_PRIORITY, .puxStackBuffer = xROAccessTaskStack, .xRegions = &#123; &#123; ucSharedMemory, SHARED_MEMORY_SIZE, portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY | portMPU_REGION_EXECUTE_NEVER &#125;, &#123; ( void * ) ucROTaskFaultTracker, SHARED_MEMORY_SIZE, portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER &#125;, &#123; 0, 0, 0 &#125;, &#125;&#125;;TaskParameters_t xRWAccessTaskParameters =&#123; .pvTaskCode = prvRWAccessTask, .pcName = &quot;RWAccess&quot;, .usStackDepth = configMINIMAL_STACK_SIZE, .pvParameters = NULL, .uxPriority = tskIDLE_PRIORITY, .puxStackBuffer = xRWAccessTaskStack, .xRegions = &#123; &#123; ucSharedMemory, SHARED_MEMORY_SIZE, portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER&#125;, &#123; 0, 0, 0 &#125;, &#123; 0, 0, 0 &#125;, &#125;&#125;; 需要MPU切换的地方 哪些时候需要进行硬件MPU的切换 xPortSysTickHandler portYIELD() portYIELD_FROM_ISR portYIELD_WITHIN_API 任务切换过程 任务切换时的需要使用软中断，切换新任务运行时需要将任务配置的MPU属性设置到硬件MPU中 Disable MPU. read and write 4 sets of MPU registers. Enable MPUFreeRTOS\\Source\\portable\\GCC\\ARM_CM3_MPU\\port.c prvRestoreContextOfFirstTask 1234567891011121314151617...&quot; dmb \\n&quot;/* Complete outstanding transfers before disabling MPU. */ &quot; ldr r2, =0xe000ed94 \\n&quot;/* MPU_CTRL register. */ &quot; ldr r3, [r2] \\n&quot;/* Read the value of MPU_CTRL. */ &quot; bic r3, #1 \\n&quot;/* r3 = r3 &amp; ~1 i.e. Clear the bit 0 in r3. */ &quot; str r3, [r2] \\n&quot;/* Disable MPU. */ &quot; \\n&quot; &quot; ldr r2, =0xe000ed9c \\n&quot;/* Region Base Address register. */ &quot; ldmia r1!, &#123;r4-r11&#125; \\n&quot;/* Read 4 sets of MPU registers. */ &quot; stmia r2!, &#123;r4-r11&#125; \\n&quot;/* Write 4 sets of MPU registers. */ &quot; \\n&quot; &quot; ldr r2, =0xe000ed94 \\n&quot;/* MPU_CTRL register. */ &quot; ldr r3, [r2] \\n&quot;/* Read the value of MPU_CTRL. */ &quot; orr r3, #1 \\n&quot;/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */ &quot; str r3, [r2] \\n&quot;/* Enable MPU. */ &quot; dsb \\n&quot;/* Force memory writes before continuing. */... xPortPendSVHandler 1234567891011121314151617... &quot; dmb \\n&quot;/* Complete outstanding transfers before disabling MPU. */ &quot; ldr r2, =0xe000ed94 \\n&quot;/* MPU_CTRL register. */ &quot; ldr r3, [r2] \\n&quot;/* Read the value of MPU_CTRL. */ &quot; bic r3, #1 \\n&quot;/* r3 = r3 &amp; ~1 i.e. Clear the bit 0 in r3. */ &quot; str r3, [r2] \\n&quot;/* Disable MPU. */ &quot; \\n&quot; &quot; ldr r2, =0xe000ed9c \\n&quot;/* Region Base Address register. */ &quot; ldmia r1!, &#123;r4-r11&#125; \\n&quot;/* Read 4 sets of MPU registers. */ &quot; stmia r2!, &#123;r4-r11&#125; \\n&quot;/* Write 4 sets of MPU registers. */ &quot; \\n&quot; &quot; ldr r2, =0xe000ed94 \\n&quot;/* MPU_CTRL register. */ &quot; ldr r3, [r2] \\n&quot;/* Read the value of MPU_CTRL. */ &quot; orr r3, #1 \\n&quot;/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */ &quot; str r3, [r2] \\n&quot;/* Enable MPU. */ &quot; dsb \\n&quot;/* Force memory writes before continuing. */...","categories":[{"name":"freertos","slug":"freertos","permalink":"https://zoug2016.github.io/categories/freertos/"},{"name":"mpu","slug":"mpu","permalink":"https://zoug2016.github.io/categories/mpu/"}],"tags":[{"name":"freertos","slug":"freertos","permalink":"https://zoug2016.github.io/tags/freertos/"},{"name":"mpu","slug":"mpu","permalink":"https://zoug2016.github.io/tags/mpu/"}],"author":"zoug2016"},{"title":"003-hexo-front-matter-rules","slug":"003-hexo-front-matter-rules","date":"2023-05-03T02:07:59.000Z","updated":"2023-05-03T03:50:34.772Z","comments":true,"path":"2023/05/03/003-hexo-front-matter-rules/","link":"","permalink":"https://zoug2016.github.io/2023/05/03/003-hexo-front-matter-rules/","excerpt":"","text":"介绍 Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 12345678---title: 003-hexo-front-matter-rulesauthor: zoug2016date: 2023-05-03 10:07:59tags: hexocategories: - hexo--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章的永久链接，永久链接应该以 / 或 .html 结尾 null excerpt 纯文本的页面摘要。使用 该插件 来格式化文本 disableNunjucks 启用时禁用 Nunjucks 标签 &#123;&#123; &#125;&#125;/&#123;% %&#125; 和 标签插件 的渲染功能 false lang 设置语言以覆盖 自动检测 继承自 _config.yml 布局 根据 _config.yml 中 default_layout 的设置，默认布局是 post 。当文章中的布局被禁用(layout: false)，它将不会使用主题处理。然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 hexo-renderer-marked)，它将被渲染成HTML。 除非通过 disableNunjucks 设置或 渲染引擎 禁用，否则无论布局如何，标签插件 总是被处理。 分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别： 分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo； 而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games 分类方法的分歧 如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法： 123categories: - Diary - Life 会使分类 Life 成为 Diary 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。 1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。 参考： Front-matter | Hexo","categories":[{"name":"hexo","slug":"hexo","permalink":"https://zoug2016.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zoug2016.github.io/tags/hexo/"}],"author":"zoug2016"},{"title":"002-ebd-basic-books","slug":"002-ebd-basic-books","date":"2023-05-03T01:31:04.000Z","updated":"2023-05-03T10:42:57.901Z","comments":true,"path":"2023/05/03/002-ebd-basic-books/","link":"","permalink":"https://zoug2016.github.io/2023/05/03/002-ebd-basic-books/","excerpt":"","text":"嵌入式学习图书与视频1. C语言 主要包括几个核心知识点：三大语法结构、常用的数据类型、函数、结构体、指针、文件操作等。 1.1. C程序设计语言C程序设计语言（原书第2版·新版 典藏版） [The C Programming Language Second Edition] C程序设计语言（原书第2版·新版 典藏版）- 京东图书 (jd.com) 1.2. C程序设计语言习题解答C程序设计语言习题解答（第2版 新版 典藏版） [The C Answer Book Second Edition 《C程序设计语言习题解答（第2版 新版 典藏版）》【摘要 书评 试读】- 京东图书 (jd.com) 1.3. C和指针C和指针 ![img](c_pointer_on_ c.png) 1.4. C 陷阱与缺陷C 陷阱与缺陷 1.5. C专家编程C专家编程","categories":[{"name":"ebd","slug":"ebd","permalink":"https://zoug2016.github.io/categories/ebd/"},{"name":"books","slug":"ebd/books","permalink":"https://zoug2016.github.io/categories/ebd/books/"}],"tags":[{"name":"books","slug":"books","permalink":"https://zoug2016.github.io/tags/books/"}],"author":"zoug2016"},{"title":"001-ebd_learn_roadmap","slug":"001-ebd-learn-roadmap-md","date":"2023-05-02T06:35:20.000Z","updated":"2023-05-03T14:57:56.763Z","comments":true,"path":"2023/05/02/001-ebd-learn-roadmap-md/","link":"","permalink":"https://zoug2016.github.io/2023/05/02/001-ebd-learn-roadmap-md/","excerpt":"","text":"嵌入式基础必备知识C语言基础 三大语法结构、常用的数据类型、函数、结构体、指针、文件操作 数据结构 数组、队列、链表、堆栈、树、图、散列表等 计算机原理 数据表示和运算、存储系统、指令系统、总线系统、中央处理器、输入输出系统等 操作系统 进程管理、内存管理、文件管理、输入输出管理等 硬件基础知识 电路基础知识、数电模电基础知识、常用的电子元器件等 CPU单片机 51单片机 软件：认识单片机、熟悉逻辑运算、点亮一颗LED灯、按键检测、串口通信、定时器、中断 硬件：电阻元器件了解，基本模块电路了解，时钟电路，尝试绘制51单片机原理图和PCB ARM处理器STM32● 基础练习 主要练习：点亮LED灯、GPIO的输入输出操作、中断操作、UART通信、IIC通信等 ● 进阶练习 主要练习：DMA通信、SPI通信、CAN通信、LCD显示屏，ADC等 ● 高阶练习 主要学习：STM32时钟架构、总线架构、电源管理、代码框架、SDIO通信、USB通信等。 ● 学习建议及资料 STM32会有寄存器和库函数两个版本，建议交叉学习，理解会更加深刻推荐正点原子、野火的STM32F103或者STM32F407系列 Cortex-MCortex-RCortex-AZynq7020[ZYNQ领航者V2开发板] (http://www.openedv.com/docs/boards/fpga/zdyz_linhanz(V2).html) RK3288https://www.t-firefly.com/product/rk3288.html RK3399firefly rk3399香橙派 Orange-Pi-R1-Plus-LTS 硬件通信接口UARTTTL、RS232&#x2F;RS485&#x2F;RS422I2CSPI&#x2F;QPSIADCPWMCAN&#x2F;CANFDUSBethernetPCI&#x2F;PCIERTOS RTOS，实时操作系统，可以理解为STM32与Linux之间的桥梁，由于其实现思想大都取之于Linux，所以也称之为精简版的Linux。 常用的实时操作系统有：UCOS，VxWork，FreeRTOS，RT-Thread 移植RTOS系统、多任务管理、调度算法、消息队列、信号量互斥量、事件、内存管理等。 FreeRTOS● FreeRTOS官网● FreeRTOS github源码 FreeRTOS(TM) is a market leading RTOS from Amazon Web Services ，包括FreeRTOS的所有工程 https://github.com/freertos FreeRTOS的工程源码，包括demo和kernel【submodule】https://github.com/FreeRTOS/FreeRTOS FreeRTOS kernel源码https://github.com/FreeRTOS/FreeRTOS-Kernel 发布的demo和kernel一起的源码版本https://github.com/FreeRTOS/FreeRTOS/releases 欢迎阅读韦东山百问网freeRTOS教程！ http://rtos.100ask.org/freeRTOS%E6%95%99%E7%A8%8B/index.htmlhttps://www.bilibili.com/video/BV1844y1g7ud?p=1 Linux Linux基础篇 Linux开发 Linux应用开发 Linux驱动开发 Linux内核开发 Linux基础篇 Linux常用命令、VIM学习、Linux的Shell编程、GCC编译、Makefile、CMake等 Linux应用开发 嵌入式linux应用编程、存储、网络、QT编程、TCP&#x2F;IP、HTTP协议等 Linux驱动开发 内核模块编译原理、字符设备驱动框架、平台设备驱动、设备树、I2C子系统、中断子系统、块设备驱动框架、Bootloader等 Linux内核开发 系统调用、存储管理、进程管理、内存管理、文件管理等","categories":[{"name":"ebd","slug":"ebd","permalink":"https://zoug2016.github.io/categories/ebd/"}],"tags":[{"name":"ebd","slug":"ebd","permalink":"https://zoug2016.github.io/tags/ebd/"}]},{"title":"000 Hello World","slug":"000-hello-world","date":"2023-05-01T06:35:20.000Z","updated":"2023-05-03T03:44:59.990Z","comments":true,"path":"2023/05/01/000-hello-world/","link":"","permalink":"https://zoug2016.github.io/2023/05/01/000-hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"cmd","slug":"cmd","permalink":"https://zoug2016.github.io/categories/cmd/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zoug2016.github.io/categories/nodejs/"},{"name":"hexo","slug":"hexo","permalink":"https://zoug2016.github.io/categories/hexo/"},{"name":"c","slug":"c","permalink":"https://zoug2016.github.io/categories/c/"},{"name":"c_pointer","slug":"c/c-pointer","permalink":"https://zoug2016.github.io/categories/c/c-pointer/"},{"name":"freertos","slug":"freertos","permalink":"https://zoug2016.github.io/categories/freertos/"},{"name":"mpu","slug":"mpu","permalink":"https://zoug2016.github.io/categories/mpu/"},{"name":"ebd","slug":"ebd","permalink":"https://zoug2016.github.io/categories/ebd/"},{"name":"books","slug":"ebd/books","permalink":"https://zoug2016.github.io/categories/ebd/books/"}],"tags":[{"name":"cmd","slug":"cmd","permalink":"https://zoug2016.github.io/tags/cmd/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zoug2016.github.io/tags/nodejs/"},{"name":"hexo","slug":"hexo","permalink":"https://zoug2016.github.io/tags/hexo/"},{"name":"c","slug":"c","permalink":"https://zoug2016.github.io/tags/c/"},{"name":"freertos","slug":"freertos","permalink":"https://zoug2016.github.io/tags/freertos/"},{"name":"mpu","slug":"mpu","permalink":"https://zoug2016.github.io/tags/mpu/"},{"name":"books","slug":"books","permalink":"https://zoug2016.github.io/tags/books/"},{"name":"ebd","slug":"ebd","permalink":"https://zoug2016.github.io/tags/ebd/"}]}