<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zoug2016</title>
  
  <subtitle>blog</subtitle>
  <link href="https://zoug2016.github.io/atom.xml" rel="self"/>
  
  <link href="https://zoug2016.github.io/"/>
  <updated>2023-05-31T15:57:29.130Z</updated>
  <id>https://zoug2016.github.io/</id>
  
  <author>
    <name>zoug2016</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>006-hexo-basic</title>
    <link href="https://zoug2016.github.io/2023/05/31/006-hexo-basic/"/>
    <id>https://zoug2016.github.io/2023/05/31/006-hexo-basic/</id>
    <published>2023-05-31T15:42:26.000Z</published>
    <updated>2023-05-31T15:57:29.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写作-new"><a href="#写作-new" class="headerlink" title="写作(new)"></a>写作(new)</h1><p>创建一篇新文章或者新的页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><blockquote><p>命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p></blockquote><p>然后使用Typora或vs code来编写markdown</p><h1 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></blockquote><p>该命令可以简写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><h1 id="server"><a href="#server" class="headerlink" title="server"></a>server</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>该命令可以简写为</p><blockquote><p>hexo s</p></blockquote><p>即可本查看浏览，没有问题后再部署</p><h1 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>该命令可以简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h1 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写作-new&quot;&gt;&lt;a href=&quot;#写作-new&quot; class=&quot;headerlink&quot; title=&quot;写作(new)&quot;&gt;&lt;/a&gt;写作(new)&lt;/h1&gt;&lt;p&gt;创建一篇新文章或者新的页面&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext</summary>
      
    
    
    
    <category term="hexo" scheme="https://zoug2016.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://zoug2016.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>005-c-pointer-summary</title>
    <link href="https://zoug2016.github.io/2023/05/05/005-c-pointer-summary/"/>
    <id>https://zoug2016.github.io/2023/05/05/005-c-pointer-summary/</id>
    <published>2023-05-05T14:40:35.000Z</published>
    <updated>2023-05-05T17:01:42.800Z</updated>
    
    <content type="html"><![CDATA[<ul><li>指针是一种保存变量地址的变量</li><li>声明解释先从最内层开始<ul><li>先从名字p的右边开始看，再到左边。</li><li>然后跳到外一层右边开始，再到外一层的左边开始看。</li><li>不断循环，直到没有符号为止</li></ul></li></ul><h1 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h1><ul><li><p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。</p><p>声明格式为：类型标识符* 函数名(参数表)</p><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int fun(int x,int y); //一个函数，然后返回值是一个 int 类型，是一个数值</span><br><span class="line">int* fun(int x,int y); //唯一的区别就是在函数名前面多了一个*号，而这个函数就是一个指针函数。其返回值是一个 int 类型的指针，是一个地址。</span><br></pre></td></tr></table></figure></blockquote></li><li><p>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。</p><p>类型说明符 (*函数名) (参数)</p><blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int (*fun)(int x,int y); </span><br><span class="line">函数指针是需要把一个函数的地址赋值给它，有两种写法：</span><br><span class="line">fun = &amp;Function；</span><br><span class="line">fun = Function;</span><br><span class="line">取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</span><br><span class="line"></span><br><span class="line">调用函数指针的方式也有两种：</span><br><span class="line">x = (*fun)();</span><br><span class="line">x = fun();</span><br><span class="line">两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。</span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h1><ul><li>指针数组</li></ul><blockquote><p> 首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身的大小决定，每一个元素都是一个指针，在32 位系统下任何类型的指针永远是占4 个字节。它是“储存指针的数组”的简称。</p></blockquote><ul><li>数组指针</li></ul><blockquote><p>首先它是一个指针，它指向一个数组。在32 位系统下任何类型的指针永远是占4 个字节，至于它指向的数组占多少字节，不知道，具体要看数组大小。它是“指向数组的指针”的简称。</p></blockquote><p>A)   int *p1[10];</p><p>B)  int (*p2)[10];</p><p>到底哪个是数组指针，哪个是指针数组呢</p><blockquote><p>“[]”的优先级比“<em>”要高。p1 先与“[]”结合，构成一个数组的定义，数组名为p1，int <em>修饰的是数组的内容，即数组的每个元素。那现在我们清楚，这是一个数组，其包含10 个指向int 类型数据的指针，即**指针数组</em></em></p></blockquote><blockquote><p>至于p2 就更好理解了，在这里“（）”的优先级比“[]”高，“*”号和p2 构成一个指针的定义，指针变量名为p2，int 修饰的是数组的内容，即数组的每个元素。数组在这里并没有名字，是个匿名数组。那现在我们清楚p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即<strong>数组指针</strong>。</p></blockquote><p>我们可以借助下面的图加深理解：</p><p><img src="/2023/05/05/005-c-pointer-summary/image-20230506005739492.png"></p><h1 id="复杂指针声明"><a href="#复杂指针声明" class="headerlink" title="复杂指针声明"></a>复杂指针声明</h1><h2 id="声明简单的指针变量"><a href="#声明简单的指针变量" class="headerlink" title="声明简单的指针变量"></a>声明简单的指针变量</h2><p>如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p; <span class="comment">//声明一个指向int类型的指针变量p</span></span><br><span class="line">p = &amp;a; <span class="comment">//把a的地址赋值给指针p</span></span><br><span class="line">*p = <span class="number">1000</span>; <span class="comment">//修改a值为1000</span></span><br></pre></td></tr></table></figure><p>这段代码声明了一个指针变量p，赋值指向了a，可通过*p访问到变量a，并对a进行值的修改。星号 * 是一元运算符，它用在不同的地方将具有不同的作用。</p><h3 id="星号-用于声明语句时的作用"><a href="#星号-用于声明语句时的作用" class="headerlink" title="星号 * 用于声明语句时的作用"></a>星号 * 用于声明语句时的作用</h3><p>上面代码中的第二行中的 * 对于指针的声明，首先从p这里开始看，这是c语言中声明的语法</p><p><strong>第1步</strong>：先看p的右边有没有其他符号（分号不算），可以看到p的右边没有符号</p><p><strong>第2步</strong>：看p的左边，在p的左边有一个星号 * ，这里的 * 作用在p上面，其产生的效果是声明变量p是一个指针。到目前只知道p是一个指针，但还不知道该指针是指向什么类型的数据</p><p><strong>第3步</strong>：星号 * 左边是数据类型int，int的作用是声明p指向的数据类型是int类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上面的int和*两个符号的发挥作用是有先后顺序的，先是 * 发挥作用声明p是一个指针，然后是int发挥作用，声明指向的数据类型是int</span><br></pre></td></tr></table></figure><h3 id="星号-用于声明语句之外时的作用"><a href="#星号-用于声明语句之外时的作用" class="headerlink" title="星号 * 用于声明语句之外时的作用"></a>星号 * 用于声明语句之外时的作用</h3><p>代码中*p &#x3D; 1000;中 * 用于声明语句之外时的作用，这句等效于 a &#x3D; 1000; 当 * 作用于指针变量p时，就时访问指针变量p所指向的变量a。</p><h2 id="复杂声明和声明语法"><a href="#复杂声明和声明语法" class="headerlink" title="复杂声明和声明语法"></a>复杂声明和声明语法</h2><h3 id="声明指向指针的指针变量"><a href="#声明指向指针的指针变量" class="headerlink" title="声明指向指针的指针变量"></a>声明指向指针的指针变量</h3><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 100;</span><br><span class="line">int *p; //声明一个指向int类型的指针变量p</span><br><span class="line">p = &amp;a; //把a的地址赋值给指针p</span><br><span class="line">int **pp;//声明指向指针的指针变量pp</span><br><span class="line">pp = &amp;p;//pp指向变量p, p是指针变量</span><br><span class="line">**p = 1000; //修改a值为1000</span><br></pre></td></tr></table></figure><p>前三行代码在前面已经介绍过了</p><p>主要对第四行开始的代码进行介绍：</p><p>第四行 int **pp;与 int *(* pp);是等效的，因为* 和 ++ 这样的一元运算符遵循从右往左的结合顺序。</p><blockquote><p>对int *(* pp)；进行分析，从变量名pp开始：</p><ul><li><p><strong>第1步</strong>：先看pp右边有一个右括号，括号只是强调结合顺序，不用管它</p></li><li><p><strong>第2步</strong>：看pp的左边，可以看到右数的第一个*, 该星号的作用是声明变量pp是一个指针，此时还不知道pp所指向的数据类型</p></li><li><p><strong>第3步</strong>：先看括号的右边，没有其他符号，分号只是语句的结束而已</p></li><li><p><strong>第4步</strong>：看括号的左边，是一个* (右数第二个星号)，这个星号的作用是：声明指针变量pp所指向的数据类型是指针类型，此时我知道了pp指向的数据类型是指针类型（即代码中p的数据类型），但还不知道所指向的指向是指向什么类型的数据。</p></li><li><p><strong>第5步</strong>：看最左边的符号是int，这个int的作用是：声明pp指向的指针所指向的数据类型是int，即pp指向的是int类型的指针。</p></li></ul></blockquote><p>总结下：<strong>pp左边第一个星号 * 声明了pp是一个指向变量，第二个星号 * 声明了指针变量pp指向的数据类型是指针类型，而类型说明符int则声明了pp指向的指针指向的数据类型是int</strong></p><h3 id="C语言中声明的语法"><a href="#C语言中声明的语法" class="headerlink" title="C语言中声明的语法"></a>C语言中声明的语法</h3><p>在c语言中解释一个声明，并不是从左到右，也不是从右到左解释，而是从变量名开始解释<strong>。声明总是由很多符号和唯一的变量名结合而成，这些符号和唯一的变量名结合就是声明符。</strong></p><p>声明的形式为：“T D”, 其中T表示类型，D代表声明符，如：</p><p>int *p;  int就是T, *p就是D。</p><p><strong>下面以变量名p和很多符号来结合组成声明符</strong>，如[], (), *。</p><ul><li><ol><li>当p与符号[]相结合（[]在p的右边）时，符号[]的作用是声明变量p是一个数组类型。[]中的数字决定了数组中的元素的个数。如下面的声明代码：</li></ol><blockquote><p>int p[10]; &#x2F;&#x2F; 声明变量p是一个整型数组，数组中有5个元素</p></blockquote><p>需要主要的是**[]的优先级比星号 * 的优先级高**。</p></li><li><ol start="2"><li>当 p 与符号 （）结合时（ （）在p的右边），符号（）的作用就是声明p时一个函数，通过p()可以调用该函数，（）中的可以有参数列表或无参数列表，如下面的代码：</li></ol><blockquote><p>int p();   &#x2F;&#x2F;声明函数p，返回类型是int</p><p>int p(int a, int b); &#x2F;&#x2F;声明一个带形参int类型的a和b的函数p，返回数据类型是int</p></blockquote><p>同样<strong>符号（）的优先级比 * 高</strong></p></li><li><ol start="3"><li>当 p和星号 * 相结合时（星号在p的左边），符号 * 的作用就是声明p是一个指针类型，如下代码：</li></ol><blockquote><p>int *p; &#x2F;&#x2F;声明p是一个指针，该指针指向int数据类型</p></blockquote></li></ul><p>介绍完这3个符号后，继续介绍语法：<strong>在介绍声明时，首先要决定声明的变量p是什么东西，而和p最近的符号则决定了p是什么东西</strong>。如下面的声明：</p><blockquote><p>int p();  &#x2F;&#x2F; p是函数</p><p>int *p; &#x2F;&#x2F; p是指针</p><p>int p[5]; &#x2F;&#x2F; p是数组</p><p>int *p[5];&#x2F;&#x2F; p是数组，数组里面有5个元素，每个元素是指向int类型的指针</p></blockquote><p>对int <em>p[5];进行下解释，由于[]的优先级比 * 高，所以[]先作用于p，故p是一个数组，再看左边是</em>，说明数组中的元素是指针类型，再往左知道了指向的是int数据类型，所以这个声明的结果就是：声明了一个数组，数组有5个元素，每个元素都是指向int整型数据的指针。</p><p>总结就是：<strong>解释声明要名字p开始</strong>，然后从<strong>p的右边开始看符号，决定了p是什么</strong>（优先级高的符号是[]和（），如果有符号先和p结合，是数组或函数），<strong>p左边的符号发挥作用</strong>（要么是*，要是什么都没有），<strong>最后发挥作用的是类型说明</strong>（它在最外面）。</p><blockquote><p>就是不断问<strong>什么</strong>，然后从里往外看符号来<strong>解答什么</strong>的过程。</p></blockquote><p>解释声明的方法就是：<strong>先从最内层开始看符号，先从名字p的右边开始看，再到左边。然后跳到外一层右边开始，再到外一层的左边开始看。不断循环，直到没有符号为止</strong></p><p>下面进行更加复杂的声明解释：</p><blockquote><p>char (*(*x())[])();</p></blockquote><p>先从最里面x变量名开始，x的右边是（），所以x是函数。 再看x的左边，是一个星号 * ，所以x是函数，返回值类型是指针类型</p><p>继续跳外一层开始，右边是[], 所以指针指向的是一个数组，再看左边是*，所以数组中的元素的类型是指针类型</p><p>再看外一层，右边是()，所以数组中的指针指向的是函数，最后看左边的类型是char，所以函数的返回值类型是char类型。</p><p><strong>整个声明</strong>就是：x是一个函数，函数的返回类型是指针类型，这个指针指向的是一个数组，这个数组是指针数组（里面元素是指针），数组中的指针是函数指针，指向的函数的返回值类型是char类型。</p><blockquote><p>char (*(*x[3])())[5];</p></blockquote><p>声明的结果是：x是一个数组，数组有3个元素，元素的类型是指针类型，指针是函数指针，所指向的函数返回值为指针，返回的指针指向数组，数组有5个元素，元素的数据类型为char类型。</p><h3 id="使用复杂声明"><a href="#使用复杂声明" class="headerlink" title="使用复杂声明"></a>使用复杂声明</h3><p>比如：声明一个函数x，函数x的返回值是指针类型，该指针指向数组，数组的元素类型为char。</p><ul><li><p>函数x</p><blockquote><p>x()</p></blockquote></li><li><p>函数x的返回值是指针类型</p><blockquote><p>*x()</p></blockquote></li><li><p>指针指向数组</p><blockquote><p>(*x())[]</p></blockquote></li><li><p>数组的元素类型为char</p><blockquote><p>char (*x())[];</p></blockquote></li></ul><p>对（*(void(*)())0)() 解释，来源于c陷阱与缺陷</p><blockquote><p>找中间位置，是一个指针，指针指向函数即函数指针。</p><p>0强制转为函数指针，然后获取函数指针的内容</p><p>进行函数调用，即对0地址进行函数调用</p></blockquote><p>优雅一点改进：</p><p>typedef  void (*pfun)(void);</p><p>(*(pfun)0)();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;指针是一种保存变量地址的变量&lt;/li&gt;
&lt;li&gt;声明解释先从最内层开始&lt;ul&gt;
&lt;li&gt;先从名字p的右边开始看，再到左边。&lt;/li&gt;
&lt;li&gt;然后跳到外一层右边开始，再到外一层的左边开始看。&lt;/li&gt;
&lt;li&gt;不断循环，直到没有符号为止&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="c" scheme="https://zoug2016.github.io/categories/c/"/>
    
    <category term="c_pointer" scheme="https://zoug2016.github.io/categories/c/c-pointer/"/>
    
    
    <category term="c" scheme="https://zoug2016.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>004-freertos-mpu-cm3-demo</title>
    <link href="https://zoug2016.github.io/2023/05/03/004-freertos-mpu-cm3-demo/"/>
    <id>https://zoug2016.github.io/2023/05/03/004-freertos-mpu-cm3-demo/</id>
    <published>2023-05-03T15:13:02.000Z</published>
    <updated>2023-05-03T16:42:54.025Z</updated>
    
    <content type="html"><![CDATA[<p>FreeRTOS中使用MPU进行任务之间的隔离，本文主要分析Cortex-M3的demo代码和kernel的实现过程</p><blockquote><p>为了任务之间安全隔离，在FeeRTOS中可以使用MPU（需硬件支持）进行任务之间的隔离，本文主要分析Cortex-M3的demo支持MPU的主要代码框架</p></blockquote><h1 id="源码说明"><a href="#源码说明" class="headerlink" title="源码说明"></a>源码说明</h1><p><a href="https://github.com/FreeRTOS/FreeRTOS%E4%B8%ADdemo%E7%9A%84%E6%BA%90%E7%A0%81%EF%BC%8C%E5%85%B6%E4%B8%ADFreeRTOS/Source%E4%B8%BAkernel%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%9C%E4%B8%BAFreeRTOS">https://github.com/FreeRTOS/FreeRTOS中demo的源码，其中FreeRTOS/Source为kernel代码，作为FreeRTOS</a> git库的submodule，其代码工程在<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel">https://github.com/FreeRTOS/FreeRTOS-Kernel</a></p><p><img src="/2023/05/03/004-freertos-mpu-cm3-demo/image-20230503232855321.png" alt="image-20230503232855321"></p><p>为了查看分析代码方便，可直接在<a href="https://github.com/FreeRTOS/FreeRTOS/releases%E4%B8%AD%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E5%8C%85%EF%BC%8C%E6%88%91%E4%B8%8B%E8%BD%BD%E5%BD%93%E5%89%8D%E6%9C%80%E6%96%B0%E7%9A%84%E6%98%AF[FreeRTOSv202212.01](https://github.com/FreeRTOS/FreeRTOS/releases/tag/202212.01)">https://github.com/FreeRTOS/FreeRTOS/releases中下载源码包，我下载当前最新的是[FreeRTOSv202212.01](https://github.com/FreeRTOS/FreeRTOS/releases/tag/202212.01)</a></p><p>解压FreeRTOSv202212.01后，要分析的M3的相关代码如下：</p><ul><li><p>App demo</p><blockquote><p>FreeRTOS\Demo\CORTEX_MPU_M3_NUCLEO_L152RE_GCC</p></blockquote><p>FreeRTOS\Demo\CORTEX_MPU_M3_NUCLEO_L152RE_GCC\Demo\mpu_demo.c</p><ul><li><p>prvROAccessTask</p><blockquote><p>Implements the task which has Read Only access to the memory region  </p><p>ucSharedMemory.</p></blockquote></li><li><p>prvRWAccessTask</p><blockquote><p>Implements the task which has Read Write access to the memory region</p><p> ucSharedMemory.</p></blockquote></li><li><p>vStartMPUDemo</p><blockquote><p>定义栈 xROAccessTaskStack 和 xRWAccessTaskStack</p><p>定义任务的参数xROAccessTaskParameters和xRWAccessTaskParameters， 包括xRegions</p><ul><li>xTaskCreateRestricted( &amp;( xROAccessTaskParameters ), NULL )</li></ul><blockquote><p>unprivileged task with RO access to ucSharedMemory.</p></blockquote><ul><li>xTaskCreateRestricted( &amp;( xRWAccessTaskParameters ), NULL )</li></ul><blockquote><p>  unprivileged task with RW access to ucSharedMemory.</p></blockquote></blockquote></li></ul></li><li><p>FreeRTOS kernel实现代码</p><blockquote><p>FreeRTOS\Source</p><p>头文件在FreeRTOS\Source\include</p><p>FreeRTOS\Source\event_groups.c</p><p>FreeRTOS\Source\list.c</p><p>FreeRTOS\Source\queue.c</p><p>FreeRTOS\Source\tasks.c</p><p>FreeRTOS\Source\timers.c</p></blockquote><ul><li><strong>实现MPU的CM3移植代码</strong></li></ul><blockquote><p>FreeRTOS\Source\portable\GCC\ARM_CM3_MPU</p></blockquote><blockquote><p>FreeRTOS\Source\portable\GCC\ARM_CM3_MPU\portmacro.h</p></blockquote><ul><li><p>Type definitions.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portCHAR          char</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portFLOAT         float</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portDOUBLE        double</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portLONG          long</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portSHORT         short</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portSTACK_TYPE    uint32_t</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> portBASE_TYPE     long</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> portSTACK_TYPE   StackType_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span>             BaseType_t;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span>    UBaseType_t;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>MPU specific constants.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MPU_REGION_REGISTERS</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> ulRegionBaseAddress;</span><br><span class="line">        <span class="type">uint32_t</span> ulRegionAttribute;</span><br><span class="line">    &#125; xMPU_REGION_REGISTERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Plus 1 to create space for the stack region. */</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MPU_SETTINGS</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        xMPU_REGION_REGISTERS xRegion[ portTOTAL_NUM_REGIONS_IN_TCB ];</span><br><span class="line">    &#125; xMPU_SETTINGS;</span><br></pre></td></tr></table></figure></li><li><p><strong>SVC numbers for various services</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> portSVC_START_SCHEDULER    0</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> portSVC_YIELD              1</span></span><br><span class="line">   <span class="meta">#<span class="keyword">define</span> portSVC_RAISE_PRIVILEGE    2</span></span><br></pre></td></tr></table></figure></li><li><p>Scheduler utilities.</p><blockquote><p>#define portYIELD()   __asm volatile ( “  SVC %0  \n”::”i” ( portSVC_YIELD ) : “memory” )</p><p>portYIELD_WITHIN_API()</p><p>portYIELD_FROM_ISR( x )</p></blockquote></li><li><p>Critical section management</p></li><li><p>Generic helper function.</p></li><li><p>Store&#x2F;clear the ready priorities in a bit map</p></li><li><p>Checks whether or not the processor is privileged.</p></li><li><p>Raise an SVC request to raise privilege.</p><blockquote><p>#define portRAISE_PRIVILEGE()   __asm volatile ( “svc %0 \n” ::”i” ( portSVC_RAISE_PRIVILEGE ) : “memory” );</p></blockquote></li><li><p>Lowers the privilege level by setting the bit 0 of the CONTROL register.</p></li></ul></li></ul><p>​    <strong>FreeRTOS\Source\portable\GCC\ARM_CM3_MPU\port.c</strong> </p><blockquote><ul><li>Constants required to access and manipulate the NVIC</li></ul></blockquote><pre><code>- Constants required to access and manipulate the MPU.  - Constants required to access and manipulate the SysTick.  - Constants required to check the validity of an interrupt priority  -  Offsets in the stack to the parameters when inside the SVC handler.  - Standard FreeRTOS exception handlers.    &gt; void xPortPendSVHandler( void ) __attribute__( ( naked ) ) PRIVILEGED_FUNCTION;  &gt;  &gt; void xPortSysTickHandler( void )  __attribute__( ( optimize( &quot;3&quot; ) ) ) PRIVILEGED_FUNCTION;  &gt;  &gt; void vPortSVCHandler( void ) __attribute__( ( naked ) ) PRIVILEGED_FUNCTION;  - Starts the scheduler by restoring the context of the first task to run.    &gt; static void prvRestoreContextOfFirstTask( void )  - C portion of the SVC handler    &gt; /*  &gt;  &gt;  \* C portion of the SVC handler.  The SVC handler is split between an asm entry  &gt;  &gt;  \* and a C wrapper for simplicity of coding and maintenance.  &gt;  &gt;  */  &gt;  &gt; static void prvSVCHandler( uint32_t * pulRegisters ) __attribute__( ( noinline ) ) PRIVILEGED_FUNCTION;  - pxPortInitialiseStack  - vPortSVCHandler    SVC软中断后执行的函数，调用过程为：    **vPortSVCHandler**       -&gt; static void prvSVCHandler( uint32_t * pulParam )    ​       -&gt; portSVC_START_SCHEDULER    ​            -&gt; prvRestoreContextOfFirstTask()    ​      -&gt; portSVC_YIELD    ​           -&gt;portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT  [**触发PENSV**]    ​      -&gt; portSVC_RAISE_PRIVILEGE      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__asm volatile</span><br><span class="line">(</span><br><span class="line">&quot;mrs r1, control\n&quot;/* Obtain current control value. */</span><br><span class="line">&quot;bic r1, #1\n&quot;/* Set privilege bit. */</span><br><span class="line">&quot;msr control, r1\n&quot;/* Write back new control value. */</span><br><span class="line">::: &quot;r1&quot;, &quot;memory&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></code></pre><p>​      </p><pre><code>- prvRestoreContextOfFirstTask  - xPortStartScheduler  - vPortEndScheduler  - vPortEnterCritical  - vPortExitCritical  - xPortPendSVHandler    - Disable MPU.   - read and write  4 sets of MPU registers.  - Enable MPU  - xPortSysTickHandler    &gt; /* Pend a context switch. */  &gt;  &gt; portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;  - vPortSetupTimerInterrupt  - prvSetupMPU  - prvGetMPURegionSizeSetting  - xIsPrivileged  - vResetPrivilege  - vPortStoreTaskMPUSettings    &gt; 在task.c中prvInitialiseNewTask和vTaskAllocateMPURegions中调用</code></pre><h1 id="任务的MPU属性配置"><a href="#任务的MPU属性配置" class="headerlink" title="任务的MPU属性配置"></a>任务的MPU属性配置</h1><p><strong>FreeRTOS\Demo\CORTEX_MPU_M3_NUCLEO_L152RE_GCC\Demo\mpu_demo.c</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">TaskParameters_t xROAccessTaskParameters =</span><br><span class="line">&#123;</span><br><span class="line">.pvTaskCode= prvROAccessTask,</span><br><span class="line">.pcName= &quot;ROAccess&quot;,</span><br><span class="line">.usStackDepth= configMINIMAL_STACK_SIZE,</span><br><span class="line">.pvParameters= NULL,</span><br><span class="line">.uxPriority= tskIDLE_PRIORITY,</span><br><span class="line">.puxStackBuffer= xROAccessTaskStack,</span><br><span class="line">.xRegions=&#123;</span><br><span class="line">&#123; ucSharedMemory,SHARED_MEMORY_SIZE,portMPU_REGION_PRIVILEGED_READ_WRITE_UNPRIV_READ_ONLY | portMPU_REGION_EXECUTE_NEVER&#125;,</span><br><span class="line">&#123; ( void * ) ucROTaskFaultTracker,SHARED_MEMORY_SIZE,portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER&#125;,</span><br><span class="line">&#123; 0,0,0&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">TaskParameters_t xRWAccessTaskParameters =</span><br><span class="line">&#123;</span><br><span class="line">.pvTaskCode= prvRWAccessTask,</span><br><span class="line">.pcName= &quot;RWAccess&quot;,</span><br><span class="line">.usStackDepth= configMINIMAL_STACK_SIZE,</span><br><span class="line">.pvParameters= NULL,</span><br><span class="line">.uxPriority= tskIDLE_PRIORITY,</span><br><span class="line">.puxStackBuffer= xRWAccessTaskStack,</span><br><span class="line">.xRegions=&#123;</span><br><span class="line">&#123; ucSharedMemory,SHARED_MEMORY_SIZE,portMPU_REGION_READ_WRITE | portMPU_REGION_EXECUTE_NEVER&#125;,</span><br><span class="line">&#123; 0,0,0&#125;,</span><br><span class="line">&#123; 0,0,0&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="需要MPU切换的地方"><a href="#需要MPU切换的地方" class="headerlink" title="需要MPU切换的地方"></a>需要MPU切换的地方</h1><blockquote><p>哪些时候需要进行硬件MPU的切换</p></blockquote><ul><li>xPortSysTickHandler</li><li>portYIELD()</li><li>portYIELD_FROM_ISR</li><li>portYIELD_WITHIN_API</li></ul><h1 id="任务切换过程"><a href="#任务切换过程" class="headerlink" title="任务切换过程"></a>任务切换过程</h1><blockquote><p>任务切换时的需要使用软中断，切换新任务运行时需要将任务配置的MPU属性设置到硬件MPU中</p></blockquote><blockquote><ul><li>Disable MPU. </li><li>read and write  4 sets of MPU registers.</li><li>Enable MPU<br><strong>FreeRTOS\Source\portable\GCC\ARM_CM3_MPU\port.c</strong></li></ul></blockquote><ul><li><p>prvRestoreContextOfFirstTask</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&quot;dmb\n&quot;/* Complete outstanding transfers before disabling MPU. */</span><br><span class="line">        &quot;ldr r2, =0xe000ed94\n&quot;/* MPU_CTRL register. */</span><br><span class="line">        &quot;ldr r3, [r2]\n&quot;/* Read the value of MPU_CTRL. */</span><br><span class="line">        &quot;bic r3, #1\n&quot;/* r3 = r3 &amp; ~1 i.e. Clear the bit 0 in r3. */</span><br><span class="line">        &quot;str r3, [r2]\n&quot;/* Disable MPU. */</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;ldr r2, =0xe000ed9c\n&quot;/* Region Base Address register. */</span><br><span class="line">        &quot;ldmia r1!, &#123;r4-r11&#125;\n&quot;/* Read 4 sets of MPU registers. */</span><br><span class="line">        &quot;stmia r2!, &#123;r4-r11&#125;\n&quot;/* Write 4 sets of MPU registers. */</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;ldr r2, =0xe000ed94\n&quot;/* MPU_CTRL register. */</span><br><span class="line">        &quot;ldr r3, [r2]\n&quot;/* Read the value of MPU_CTRL. */</span><br><span class="line">        &quot;orr r3, #1\n&quot;/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */</span><br><span class="line">        &quot;str r3, [r2]\n&quot;/* Enable MPU. */</span><br><span class="line">        &quot;dsb\n&quot;/* Force memory writes before continuing. */</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>xPortPendSVHandler</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        &quot;dmb\n&quot;/* Complete outstanding transfers before disabling MPU. */</span><br><span class="line">        &quot;ldr r2, =0xe000ed94\n&quot;/* MPU_CTRL register. */</span><br><span class="line">        &quot;ldr r3, [r2]\n&quot;/* Read the value of MPU_CTRL. */</span><br><span class="line">        &quot;bic r3, #1\n&quot;/* r3 = r3 &amp; ~1 i.e. Clear the bit 0 in r3. */</span><br><span class="line">        &quot;str r3, [r2]\n&quot;/* Disable MPU. */</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;ldr r2, =0xe000ed9c\n&quot;/* Region Base Address register. */</span><br><span class="line">        &quot;ldmia r1!, &#123;r4-r11&#125;\n&quot;/* Read 4 sets of MPU registers. */</span><br><span class="line">        &quot;stmia r2!, &#123;r4-r11&#125;\n&quot;/* Write 4 sets of MPU registers. */</span><br><span class="line">        &quot;\n&quot;</span><br><span class="line">        &quot;ldr r2, =0xe000ed94\n&quot;/* MPU_CTRL register. */</span><br><span class="line">        &quot;ldr r3, [r2]\n&quot;/* Read the value of MPU_CTRL. */</span><br><span class="line">        &quot;orr r3, #1\n&quot;/* r3 = r3 | 1 i.e. Set the bit 0 in r3. */</span><br><span class="line">        &quot;str r3, [r2]\n&quot;/* Enable MPU. */</span><br><span class="line">        &quot;dsb\n&quot;/* Force memory writes before continuing. */</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;FreeRTOS中使用MPU进行任务之间的隔离，本文主要分析Cortex-M3的demo代码和kernel的实现过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了任务之间安全隔离，在FeeRTOS中可以使用MPU（需硬件支持）进行任务之间的隔离，本文主要分析Cortex-M</summary>
      
    
    
    
    <category term="freertos" scheme="https://zoug2016.github.io/categories/freertos/"/>
    
    <category term="mpu" scheme="https://zoug2016.github.io/categories/mpu/"/>
    
    
    <category term="freertos" scheme="https://zoug2016.github.io/tags/freertos/"/>
    
    <category term="mpu" scheme="https://zoug2016.github.io/tags/mpu/"/>
    
  </entry>
  
  <entry>
    <title>003-hexo-front-matter-rules</title>
    <link href="https://zoug2016.github.io/2023/05/03/003-hexo-front-matter-rules/"/>
    <id>https://zoug2016.github.io/2023/05/03/003-hexo-front-matter-rules/</id>
    <published>2023-05-03T02:07:59.000Z</published>
    <updated>2023-05-03T03:50:34.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 003-hexo-front-matter-rules</span><br><span class="line">author: zoug2016</span><br><span class="line">date: 2023-05-03 10:07:59</span><br><span class="line">tags: hexo</span><br><span class="line">categories:</span><br><span class="line">    - hexo</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>layout</code></td><td style="text-align:left">布局</td><td style="text-align:left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td></tr><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">标题</td><td style="text-align:left">文章的文件名</td></tr><tr><td style="text-align:left"><code>date</code></td><td style="text-align:left">建立日期</td><td style="text-align:left">文件建立日期</td></tr><tr><td style="text-align:left"><code>updated</code></td><td style="text-align:left">更新日期</td><td style="text-align:left">文件更新日期</td></tr><tr><td style="text-align:left"><code>comments</code></td><td style="text-align:left">开启文章的评论功能</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left"><code>tags</code></td><td style="text-align:left">标签（不适用于分页）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>categories</code></td><td style="text-align:left">分类（不适用于分页）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>permalink</code></td><td style="text-align:left">覆盖文章的永久链接，永久链接应该以 <code>/</code> 或 <code>.html</code> 结尾</td><td style="text-align:left"><code>null</code></td></tr><tr><td style="text-align:left"><code>excerpt</code></td><td style="text-align:left">纯文本的页面摘要。使用 <a href="https://hexo.io/zh-cn/docs/tag-plugins#%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E5%92%8C%E6%88%AA%E6%96%AD">该插件</a> 来格式化文本</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>disableNunjucks</code></td><td style="text-align:left">启用时禁用 Nunjucks 标签 <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> 和 <a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 的渲染功能</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left"><code>lang</code></td><td style="text-align:left">设置语言以覆盖 <a href="https://hexo.io/zh-cn/docs/internationalization#%E8%B7%AF%E5%BE%84">自动检测</a></td><td style="text-align:left">继承自 <code>_config.yml</code></td></tr></tbody></table><h1 id="布局"><a class="markdownIt-Anchor" href="#布局"></a> 布局</h1><p>根据 <code>_config.yml</code> 中 <a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>default_layout</code></a> 的设置，默认布局是 <code>post</code> 。当文章中的布局被禁用(<code>layout: false</code>)，它将不会使用主题处理。然而，它仍然会被任何可用的渲染引擎渲染：如果一篇文章是用 Markdown 写的，并且安装了 Markdown 渲染引擎（比如默认的 <a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a>)，它将被渲染成HTML。</p><p>除非通过 <code>disableNunjucks</code> 设置或 <a href="https://hexo.io/zh-cn/api/renderer#%E7%A6%81%E7%94%A8-Nunjucks-%E6%A0%87%E7%AD%BE">渲染引擎</a> 禁用，否则无论布局如何，<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件</a> 总是被处理。</p><h1 id="分类和标签"><a class="markdownIt-Anchor" href="#分类和标签"></a> 分类和标签</h1><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：</p><ul><li>分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；</li><li>而标签没有顺序和层次。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure><p><strong>分类方法的分歧</strong></p><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure><p>会使分类 <code>Life</code> 成为 <code>Diary</code> 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考：</h1><ul><li><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#介绍&quot;&gt;&lt;/a&gt; 介绍&lt;/h1&gt;
&lt;p&gt;Front-matter 是文件最上方以 &lt;code&gt;---&lt;/code&gt; 分隔的区域，用于指定个别文件的变量，举例来说：&lt;/p&gt;
&lt;figur</summary>
      
    
    
    
    <category term="hexo" scheme="https://zoug2016.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://zoug2016.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>002-ebd-basic-books</title>
    <link href="https://zoug2016.github.io/2023/05/03/002-ebd-basic-books/"/>
    <id>https://zoug2016.github.io/2023/05/03/002-ebd-basic-books/</id>
    <published>2023-05-03T01:31:04.000Z</published>
    <updated>2023-05-03T10:42:57.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式学习图书与视频"><a href="#嵌入式学习图书与视频" class="headerlink" title="嵌入式学习图书与视频"></a>嵌入式学习图书与视频</h1><h1 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1. C语言"></a>1. C语言</h1><p> 主要包括几个核心知识点：<strong>三大语法结构</strong>、<strong>常用的数据类型</strong>、<strong>函数</strong>、<strong>结构体</strong>、<strong>指针</strong>、<strong>文件操作</strong>等。  </p><h2 id="1-1-C程序设计语言"><a href="#1-1-C程序设计语言" class="headerlink" title="1.1.  C程序设计语言"></a>1.1.  C程序设计语言</h2><p>C程序设计语言（原书第2版·新版 典藏版） [The C Programming Language Second Edition]</p><p><a href="https://item.jd.com/12580612.html">C程序设计语言（原书第2版·新版 典藏版）- 京东图书 (jd.com)</a></p><p><img src="/2023/05/03/002-ebd-basic-books/c_programming_language.jpg" alt="C程序设计语言"></p><h2 id="1-2-C程序设计语言习题解答"><a href="#1-2-C程序设计语言习题解答" class="headerlink" title="1.2.  C程序设计语言习题解答"></a>1.2.  C程序设计语言习题解答</h2><p>C程序设计语言习题解答（第2版 新版 典藏版） [The C Answer Book Second Edition</p><p><a href="https://item.jd.com/12511701.html#crumb-wrap">《C程序设计语言习题解答（第2版 新版 典藏版）》【摘要 书评 试读】- 京东图书 (jd.com)</a></p><p><img src="/2023/05/03/002-ebd-basic-books/c_programming_language_answer_book.jpg" alt="C程序设计语言习题解答（第2版 新版 典藏版）"></p><h2 id="1-3-C和指针"><a href="#1-3-C和指针" class="headerlink" title="1.3. C和指针"></a>1.3. <strong>C和指针</strong></h2><p><a href="https://item.jd.com/12956672.html">C和指针</a></p><p>![img](c_pointer_on_ c.png)</p><h2 id="1-4-C-陷阱与缺陷"><a href="#1-4-C-陷阱与缺陷" class="headerlink" title="1.4. C 陷阱与缺陷"></a>1.4. <strong>C 陷阱与缺陷</strong></h2><p><a href="https://item.jd.com/12970606.html">C 陷阱与缺陷</a></p><p><img src="/2023/05/03/002-ebd-basic-books/c_traps_and_pitfalls.png" alt="img"></p><h2 id="1-5-C专家编程"><a href="#1-5-C专家编程" class="headerlink" title="1.5. C专家编程"></a>1.5. <strong>C专家编程</strong></h2><p><a href="https://item.jd.com/12976420.html">C专家编程</a></p><p><img src="/2023/05/03/002-ebd-basic-books/expert_c_progamming.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;嵌入式学习图书与视频&quot;&gt;&lt;a href=&quot;#嵌入式学习图书与视频&quot; class=&quot;headerlink&quot; title=&quot;嵌入式学习图书与视频&quot;&gt;&lt;/a&gt;嵌入式学习图书与视频&lt;/h1&gt;&lt;h1 id=&quot;1-C语言&quot;&gt;&lt;a href=&quot;#1-C语言&quot; class=&quot;he</summary>
      
    
    
    
    <category term="ebd" scheme="https://zoug2016.github.io/categories/ebd/"/>
    
    <category term="books" scheme="https://zoug2016.github.io/categories/ebd/books/"/>
    
    
    <category term="books" scheme="https://zoug2016.github.io/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>001-ebd_learn_roadmap</title>
    <link href="https://zoug2016.github.io/2023/05/02/001-ebd-learn-roadmap-md/"/>
    <id>https://zoug2016.github.io/2023/05/02/001-ebd-learn-roadmap-md/</id>
    <published>2023-05-02T06:35:20.000Z</published>
    <updated>2023-05-03T14:57:56.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式基础必备知识"><a href="#嵌入式基础必备知识" class="headerlink" title="嵌入式基础必备知识"></a>嵌入式基础必备知识</h1><h2 id="C语言基础"><a href="#C语言基础" class="headerlink" title="C语言基础"></a>C语言基础</h2><blockquote><p>三大语法结构、常用的数据类型、函数、结构体、指针、文件操作</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><blockquote><p>数组、队列、链表、堆栈、树、图、散列表等  </p></blockquote><h2 id="计算机原理"><a href="#计算机原理" class="headerlink" title="计算机原理"></a>计算机原理</h2><blockquote><p>数据表示和运算、存储系统、指令系统、总线系统、中央处理器、输入输出系统等  </p></blockquote><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p>进程管理、内存管理、文件管理、输入输出管理等  </p></blockquote><h2 id="硬件基础知识"><a href="#硬件基础知识" class="headerlink" title="硬件基础知识"></a>硬件基础知识</h2><blockquote><p>电路基础知识、数电模电基础知识、常用的电子元器件等  </p></blockquote><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="单片机"><a href="#单片机" class="headerlink" title="单片机"></a>单片机</h2><ul><li>51单片机<ul><li>软件：认识单片机、熟悉逻辑运算、点亮一颗LED灯、按键检测、串口通信、定时器、中断</li><li>硬件：电阻元器件了解，基本模块电路了解，时钟电路，尝试绘制51单片机原理图和PCB</li></ul></li></ul><h2 id="ARM处理器"><a href="#ARM处理器" class="headerlink" title="ARM处理器"></a>ARM处理器</h2><h3 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h3><p>● 基础练习</p><blockquote><p> 主要练习：点亮LED灯、GPIO的输入输出操作、中断操作、UART通信、IIC通信等  </p></blockquote><p>● 进阶练习</p><blockquote><p>主要练习：DMA通信、SPI通信、CAN通信、LCD显示屏，ADC等  </p></blockquote><p>● 高阶练习</p><blockquote><p>主要学习：STM32时钟架构、总线架构、电源管理、代码框架、SDIO通信、USB通信等。 </p></blockquote><p>● 学习建议及资料</p><blockquote><p>STM32会有寄存器和库函数两个版本，建议交叉学习，理解会更加深刻推荐正点原子、野火的STM32F103或者STM32F407系列</p></blockquote><h3 id="Cortex-M"><a href="#Cortex-M" class="headerlink" title="Cortex-M"></a>Cortex-M</h3><h3 id="Cortex-R"><a href="#Cortex-R" class="headerlink" title="Cortex-R"></a>Cortex-R</h3><h3 id="Cortex-A"><a href="#Cortex-A" class="headerlink" title="Cortex-A"></a>Cortex-A</h3><h4 id="Zynq7020"><a href="#Zynq7020" class="headerlink" title="Zynq7020"></a>Zynq7020</h4><p>[ZYNQ领航者V2开发板] (<a href="http://www.openedv.com/docs/boards/fpga/zdyz_linhanz(V2).html">http://www.openedv.com/docs/boards/fpga/zdyz_linhanz(V2).html</a>)</p><h4 id="RK3288"><a href="#RK3288" class="headerlink" title="RK3288"></a>RK3288</h4><p><a href="https://www.t-firefly.com/product/rk3288.html">https://www.t-firefly.com/product/rk3288.html</a></p><h4 id="RK3399"><a href="#RK3399" class="headerlink" title="RK3399"></a>RK3399</h4><p><a href="https://www.t-firefly.com/product/rk3399.html">firefly rk3399</a><br><a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/index.html">香橙派</a></p><p><a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/details/Orange-Pi-R1-Plus-LTS.html">Orange-Pi-R1-Plus-LTS</a></p><h1 id="硬件通信接口"><a href="#硬件通信接口" class="headerlink" title="硬件通信接口"></a>硬件通信接口</h1><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><h2 id="TTL、RS232-x2F-RS485-x2F-RS422"><a href="#TTL、RS232-x2F-RS485-x2F-RS422" class="headerlink" title="TTL、RS232&#x2F;RS485&#x2F;RS422"></a>TTL、RS232&#x2F;RS485&#x2F;RS422</h2><h2 id="I2C"><a href="#I2C" class="headerlink" title="I2C"></a>I2C</h2><h2 id="SPI-x2F-QPSI"><a href="#SPI-x2F-QPSI" class="headerlink" title="SPI&#x2F;QPSI"></a>SPI&#x2F;QPSI</h2><h2 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h2><h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><h2 id="CAN-x2F-CANFD"><a href="#CAN-x2F-CANFD" class="headerlink" title="CAN&#x2F;CANFD"></a>CAN&#x2F;CANFD</h2><h2 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h2><h2 id="ethernet"><a href="#ethernet" class="headerlink" title="ethernet"></a>ethernet</h2><h2 id="PCI-x2F-PCIE"><a href="#PCI-x2F-PCIE" class="headerlink" title="PCI&#x2F;PCIE"></a>PCI&#x2F;PCIE</h2><h1 id="RTOS"><a href="#RTOS" class="headerlink" title="RTOS"></a>RTOS</h1><blockquote><p>RTOS，实时操作系统，可以理解为STM32与Linux之间的桥梁，由于其实现思想大都取之于Linux，所以也称之为精简版的Linux。<br> 常用的实时操作系统有：UCOS，VxWork，FreeRTOS，RT-Thread</p></blockquote><p>移植RTOS系统、多任务管理、调度算法、消息队列、信号量互斥量、事件、内存管理等。 </p><h2 id="FreeRTOS"><a href="#FreeRTOS" class="headerlink" title="FreeRTOS"></a>FreeRTOS</h2><p>● <a href="https://www.freertos.org/">FreeRTOS官网</a><br>● FreeRTOS github源码</p><blockquote><p>FreeRTOS(TM) is a market leading RTOS from Amazon Web Services  ，包括FreeRTOS的所有工程</p></blockquote><ul><li><p><a href="https://github.com/freertos">https://github.com/freertos</a></p></li><li><p>FreeRTOS的工程源码，包括demo和kernel【submodule】<br><a href="https://github.com/FreeRTOS/FreeRTOS">https://github.com/FreeRTOS/FreeRTOS</a></p></li><li><p>FreeRTOS kernel源码<br><a href="https://github.com/FreeRTOS/FreeRTOS-Kernel">https://github.com/FreeRTOS/FreeRTOS-Kernel</a></p></li><li><p>发布的demo和kernel一起的源码版本<br><a href="https://github.com/FreeRTOS/FreeRTOS/releases">https://github.com/FreeRTOS/FreeRTOS/releases</a></p></li></ul><p><a href="http://rtos.100ask.org/freeRTOS%E6%95%99%E7%A8%8B/index.htmlhttps://www.bilibili.com/video/BV1844y1g7ud?p=1">欢迎阅读韦东山百问网freeRTOS教程！</a>   </p><blockquote><p><a href="http://rtos.100ask.org/freeRTOS%E6%95%99%E7%A8%8B/index.htmlhttps://www.bilibili.com/video/BV1844y1g7ud?p=1">http://rtos.100ask.org/freeRTOS%E6%95%99%E7%A8%8B/index.htmlhttps://www.bilibili.com/video/BV1844y1g7ud?p=1</a></p></blockquote><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><ul><li>Linux基础篇</li><li>Linux开发<ul><li>Linux应用开发</li><li>Linux驱动开发</li><li>Linux内核开发</li></ul></li></ul><h2 id="Linux基础篇"><a href="#Linux基础篇" class="headerlink" title="Linux基础篇"></a>Linux基础篇</h2><blockquote><p> Linux常用命令、VIM学习、Linux的Shell编程、GCC编译、Makefile、CMake等  </p></blockquote><h2 id="Linux应用开发"><a href="#Linux应用开发" class="headerlink" title="Linux应用开发"></a>Linux应用开发</h2><blockquote><p>嵌入式linux应用编程、存储、网络、QT编程、TCP&#x2F;IP、HTTP协议等  </p></blockquote><h2 id="Linux驱动开发"><a href="#Linux驱动开发" class="headerlink" title="Linux驱动开发"></a>Linux驱动开发</h2><blockquote><p>内核模块编译原理、字符设备驱动框架、平台设备驱动、设备树、I2C子系统、中断子系统、块设备驱动框架、Bootloader等  </p></blockquote><h2 id="Linux内核开发"><a href="#Linux内核开发" class="headerlink" title="Linux内核开发"></a>Linux内核开发</h2><blockquote><p>系统调用、存储管理、进程管理、内存管理、文件管理等</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;嵌入式基础必备知识&quot;&gt;&lt;a href=&quot;#嵌入式基础必备知识&quot; class=&quot;headerlink&quot; title=&quot;嵌入式基础必备知识&quot;&gt;&lt;/a&gt;嵌入式基础必备知识&lt;/h1&gt;&lt;h2 id=&quot;C语言基础&quot;&gt;&lt;a href=&quot;#C语言基础&quot; class=&quot;header</summary>
      
    
    
    
    <category term="ebd" scheme="https://zoug2016.github.io/categories/ebd/"/>
    
    
    <category term="ebd" scheme="https://zoug2016.github.io/tags/ebd/"/>
    
  </entry>
  
  <entry>
    <title>000 Hello World</title>
    <link href="https://zoug2016.github.io/2023/05/01/000-hello-world/"/>
    <id>https://zoug2016.github.io/2023/05/01/000-hello-world/</id>
    <published>2023-05-01T06:35:20.000Z</published>
    <updated>2023-05-03T03:44:59.990Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
